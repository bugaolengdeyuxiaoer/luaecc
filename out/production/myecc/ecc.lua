---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by yj.
--- DateTime: 2020/4/3 15:57
---
local bit = require("bit")
local uint64 = {0,0}
local number_ecc_digits = 16
local number_ecc_bytes = 32
local max_tries = 16
local EccPoint = {
    x = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    y = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
}
function EccPoint.new()
    return {
        x = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        y = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
    }
end
--local Curve_P = {0xFFFFFFFE,0xFFFFFC2F,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF}
--local Curve_B = {0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
--local Curve_G = {0x59F2815B,0x16F81798,0x029BFCDB,0x2DCE28D9,0x55A06295,0xCE870B07,0x79BE667E,0xF9DCBBAC,
--                 0x9C47D08F,0xFB10D4B8,0xFD17B448,0xA6855419,0x5DA4FBFC,0x0E1108A8,0x483ADA77,0x25A3C465}
--local Curve_N = {0xBFD25E8C,0xD0364141,0xBAAEDCE6,0xAF48A038,0xFFFFFFFF,0xFFFFFFFE,0xFFFFFFFF,0xFFFFFFFF}

local Curve_P = {0xFC2F,0xFFFF,0xFFFE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF}
local Curve_B = {0x0007,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000}
local Curve_G = {x = {0x1798,0x16F8,0x815B,0x59F2,0x28D9,0x2DCE,0xFCDB,0x029B,0x0B07,0xCE87,0x6295,0x55A0,0xBBAC,0xF9DC,0x667E,0x79BE},
                y = {0xD4B8,0xFB10,0xD08F,0x9C47,0x5419,0xA685,0xB448,0xFD17,0x08A8,0x0E11,0xFBFC,0x5DA4,0xC465,0x25A3,0xDA77,0x483A}}
local Curve_N = {0x4141,0xD036,0x5E8C,0xBFD2,0xA038,0xAF48,0xDCE6,0xBAAE,0xFFFE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF}
function ecdsa_verify()

end
function getRandomNumber(p_vli)
    for i = 1,number_ecc_digits do
        p_vli [i] = math.random(1,65536)
    end
end
function XYcZ_initial_double(X1,Y1,X2,Y2,p_initialZ)
    local z = {}
    vli_set(X2,X1)
    vli_set(Y2,Y1)

    vli_clear(z)
    z[1] = 1
    if p_initialZ ~= nil then
        vli_set(z,p_initialZ)
    end
    apply_z(X1,Y1,z)
    eccPoint_double_jacobian(X1,Y1,z)
    apply_z(X2,Y2,z)
end

-- Input P = (X1,Y1,Z) Q = (X2,Y2,Z)
-- Output P' = (X1,Y1,Z3) P + Q = (X3,Y3,Z3)
-- or P => P'  ,Q => P+Q
function XYcZ_add(X1,Y1,X2,Y2)
    local t5 = {}
    vli_modSub(t5,X2,X1,Curve_P)  --t5 = x2-x1
    vli_modSquare_fast(t5,t5)  --t5 = (x2-x1)^2 =A
    vli_modMult_fast(X1,X1,t5)  --t1 = x1*A =B
    vli_modMult_fast(X2,X2,t5)  --t3 = x2*A = C
    vli_modSub(Y2,Y2,Y1,Curve_P)  --t4 = y2-y1
    vli_modSquare_fast(t5,Y2)  --t5 = (y2-y1)^2 =D

    vli_modSub(t5,t5,X1,Curve_P)  --t5 = D-B
    vli_modSub(t5,t5,X2,Curve_P)  --t5 = D-B -C = x3
    vli_modSub(X2,X2,X1,Curve_P)  --t3 = C-B
    vli_modMult_fast(Y1,Y1,X2)  --t2 = y1*(C-B)
    vli_modSub(X2,X1,t5,Curve_P)  --t3 = B-x3
    vli_modMult_fast(Y2,Y2,X2)  --t4 = (y2-y1)*(B-x3)
    vli_modSub(Y2,Y2,Y1,Curve_P)  --t4 = y3

    vli_set(X2,t5)
end
function XYcZ_addC(X1,Y1,X2,Y2)
    local t5 = {}
    local t6 = {}
    local t7 = {}
    vli_modSub(t5,X2,X1,Curve_P)  --t5 = x2-x1
    vli_modSquare_fast(t5,t5)  --t5 = x2-x1
    vli_modMult_fast(X1,X1,t5) --t1 = x1 *A = B
    vli_modMult_fast(X2,X2,t5) --t3 = x2*A =C
    vli_modAdd(t5,Y2,Y1,Curve_P) --t4 =y2 + y1
    vli_modSub(Y2,Y2,Y1,Curve_P) --t4 = y2-y1

    vli_modSub(t6,X2,X1,Curve_P)  --t6 =C-B
    vli_modMult_fast(Y1,Y1,t6)  --t5 = y1*(C-B)
    vli_modAdd(t6,X1,X2,Curve_P)  --t6 = B+C
    vli_modSquare_fast(X2,Y2)  --t3 = (y2-y1)^2
    vli_modSub(X2,X2,t6,Curve_P)  --t3 = x3

    vli_modSub(t7,X1,X2,Curve_P)  --t7 = B-x3
    vli_modMult_fast(Y2,Y2,t7)  --t4 = (y2-y1)*(B- X3)
    vli_modSub(Y2,Y2,Y1,Curve_P)  --t4 =y3

    vli_modSquare_fast(t7,t5)  --t7 =(y2 +y1)^2 = F
    vli_modSub(t7,t7,t6,Curve_P)  --t7 = x3'
    vli_modSub(t6,t7,X1,Curve_P)  --t6 = x3'-B
    vli_modMult_fast(t6,t6,t5)  --t6 = (y2+y1)*(x3' - B)
    vli_modSub(Y1,t6,Y1,Curve_P)  --t2 = y3'

    vli_set(X1,t7)
end

function apply_z(X1,Y1,Z)
    local t1 ={}
    vli_modSquare_fast(t1,Z) --Z^2
    vli_modMult_fast(X1,X1,t1) --x1*Z^2
    vli_modMult_fast(t1,t1,Z) --Z^3
    vli_modMult_fast(Y1,Y1,t1) --y1*Z^3

end
---EccPoint p_result EccPoint p_point uint64 p_scalar uint64 p_initialZ
function eccPoint_mult(p_result,p_point,p_scalar,p_initialZ)
    --Ro and R1
    local Rx = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}}
    local Ry = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}}
    local z = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}

    local nb
    vli_set(Rx[2],p_point.x)
    vli_set(Ry[2],p_point.y)
    XYcZ_initial_double(Rx[2],Ry[2],Rx[1],Ry[1],p_initialZ)
    for i = vli_numBits(p_scalar)-1,2,-1 do
        print(i)
        if vli_isZero(vli_testBit(p_scalar,i))  then
            nb = 1
        else
            nb = 0
        end
        XYcZ_addC(Rx[1-nb+1],Ry[1-nb+1],Rx[nb+1],Ry[nb+1])
        XYcZ_add(Rx[nb+1],Ry[nb+1],Rx[1-nb+1],Ry[1-nb+1])

    end
    if vli_isZero(vli_testBit(p_scalar,0))  then
        nb = 1
    else
        nb = 0
    end
    XYcZ_addC(Rx[1-nb+1],Ry[1-nb+1],Rx[nb+1],Ry[nb+1])

    --find final 1/Z value
    vli_modSub(z,Rx[2],Rx[1],Curve_P)
    vli_modMult_fast(z,z,Ry[1-nb+1])
    vli_modMult_fast(z,z,p_point.x)
    vil_modInv(z,z,Curve_P)
    vli_modMult_fast(z,z,p_point.y)
    vli_modMult_fast(z,z,Rx[1-nb+1])

    XYcZ_add(Rx[nb+1],Ry[nb+1],Rx[1-nb+1],Ry[1-nb+1])
    apply_z(Rx[1],Ry[1],z)

    vli_set(p_result.x,Rx[1])
    vli_set(p_result.y,Ry[1])
end
--p_bytes is uint8 array
function ecc_bytes2native(p_native,p_bytes)
    for i = 1,number_ecc_digits do
        local p_digit = 2*(number_ecc_digits-i)
        p_native[i] = bit.bor(bit.lshift(p_bytes[p_digit+1],8),p_bytes[p_digit+2])
    end
end
--p_bytes is uint8 array
function ecc_native2bytes(p_bytes,p_native)
    for i = 1,number_ecc_digits do
        local p_digit = number_ecc_digits-i+1
        p_bytes[i*2-1] = bit.rshift(p_native[p_digit],8)
        p_bytes[i*2] = bit.band(p_native[p_digit],0xff)
    end
end
function vli_numDigits(p_vli)
    local j =number_ecc_digits
    for i = number_ecc_digits ,1,-1  do
        if p_vli[i]~=0 then
            j = i
            break
        end
        j = j-1
    end
    return j
end

function vli_numBits(p_vli)
    local i = 0
    local l_digit = 0
    local l_numDigits = vli_numDigits(p_vli)
    if(l_numDigits == 0) then
        return 0
    end
    i = (l_numDigits-1) *16
    l_digit = p_vli[l_numDigits]
    while l_digit>0 do
        i = i+1
        l_digit = bit.rshift(l_digit,1)
    end
    return i
end

function vli_isZero(p_vli)
    for i =1,number_ecc_digits do
        if p_vli[i]~=0 then
            return false
        end
    end
    return true
end

function vli_clear(p_vli)
    for i =1,number_ecc_digits do
        p_vli[i]=0
    end
    return 1
end
function vli_set(p_dest,p_src)
    for i =1,number_ecc_digits do
        p_dest[i] = p_src[i]
    end
end

--returns nonzeor if bit p_bit of p_vli is set
function vli_testBit(p_vli,p_bit)
    local r = {}
    local a = math.floor(p_bit/16)
    b = a
    while b>4 do
        b = b-4
    end
    r [1]  = 0
    r [2]  = 0
    r [3]  = 0
    r [4]  = 0
    r[b] = bit.band(p_vli[a+1],bit.lshift(1,p_bit%16))
    return r
end

function vli_cmp(p_left,p_right)
    for i =number_ecc_digits,1,-1 do
        if p_left[i]>p_right[i] then
            return 1
        elseif  p_left[i]<p_right[i] then
            return -1
        end
    end
    return 0
end
function vli_lshift(p_result,p_in,p_shift)
    local l_carry =0
    for i = 1,number_ecc_digits do
        local l_temp = p_in[i]
        p_result[i] = bit.bor(bit.lshift(l_temp,p_shift),l_carry)
        l_carry = bit.rshift(l_temp,16-p_shift)
    end
    return l_carry
end
function vli_rshift(p_result,p_in,p_shift)
    local l_carry = 0
    for i = number_ecc_digits,1,-1 do
        local l_temp = p_in[i]
        p_result[i] = bit.bor(bit.rshift(l_temp,p_shift),l_carry)
        l_carry = bit.lshift(l_temp,16-p_shift)
    end
    return l_carry
end
--rshift 1 bit
function vli_rshift1(p_in)
    local l_carry = 0
    local p_temp = 0
    local p_vil = number_ecc_digits
    for i = p_vil,1 do
        p_temp = p_in[i]
        p_in[i] = bit.bor(bit.rshift(p_in[i],1),l_carry)
        l_carry = bit.lshift(p_temp,15)
    end
end

--computes p_result = p_left+p_right ,return carry
function vli_add(p_result,p_left,p_right)
    local l_carry = 0
    local p_temp = 0
    for i = 1,number_ecc_digits do
        local l_sum = p_left[i]+p_right[i]+l_carry
        if l_sum ~= p_left[i] then
            if (l_sum >65535) then
                l_carry =  1
            else
                l_carry = 0
            end
        end
        if l_sum >65535 then
            p_result[i] = l_sum - 65536
        else
            p_result[i] = l_sum
        end
    end
    return l_carry
end
--computes p_result = p_left-p_right ,return carry
function vli_sub(p_result,p_left,p_right)
    local l_borrow = 0
    for i = 1,number_ecc_digits do
        local l_diff = p_left[i]-p_right[i]-l_borrow
        if l_diff ~= p_left[i] then
            if (l_diff <0) then
                l_borrow = 1
            else
                l_borrow = 0
            end
        end
        if(l_diff<0) then
            p_result[i] = l_diff +65535
        else
            p_result[i] = l_diff
        end
    end
    return l_borrow
end

function vli_mult(p_result,p_left,p_right)
    local r01= 0;
    for k =1 ,number_ecc_digits*2 do
        local l_min = (k<number_ecc_digits) and 1 or (k+1)-number_ecc_digits
        for i = l_min , k  do
            if(i<=number_ecc_digits) then
                local l_product = p_left[i] * p_right[k-i+1]
                r01 = r01 + l_product
            else
                break
            end
        end
        p_result[k] = bit.band(bit.lshift(2,16),r01)
        r01 = bit.rshift(r01,16)
    end
    p_result[number_ecc_digits*2] = bit.rshift(r01,16)
end
-- computes p_result^2
function vli_square(p_result,p_left)
    local r01 = 0
    --local r2 = 0
    local i = 0
    for k =1,number_ecc_digits*2 do
        local l_min =  (k<number_ecc_digits) and 1 or (k+2-number_ecc_digits)
        for i = l_min,k  do
            if (i>k-i+1) then
                break
            end
            local l_product = p_left[i] * p_left[k-i+1]
            if i < k - i then
                --r2 = r2 + bit.rshift(l_product,31)
                l_product = l_product*2
            end
            r01  =r01 + l_product
        end
        p_result[k] = bit.band(0xffff,r01)
        r01 = bit.rshift(r01,16)
    end
    p_result[number_ecc_digits*2] = bit.rshift(r01,16)
end

function vli_modAdd(p_result,p_left,p_right,p_mod)
    local l_carry = vli_add(p_result,p_left,p_right)
    if l_carry >=1 then
        vli_sub(p_result,p_result,p_mod)
    elseif  vli_cmp(p_result,p_mod)>=0 then
        vli_sub(p_result,p_result,p_mod)
    end

end
function vli_modSub(p_result,p_left,p_right,p_mod)
    local l_borrow = vli_sub(p_result,p_left,p_right)
    if l_borrow ~= 0 then
        vli_add(p_result,p_result,p_mod)
    end
end
function vli_subTable(p_left,p,q)
    local o = 1
    local p_result = {}
    for k = p,q do
        p_result [o] = p_left[k]
        o = o + 1
    end
    return p_result
end
function vli_mmod_fast(p_result,p_product)
    local l_tmp = {}
    local l_carry
    vli_set(p_result,p_product)
    --s1--
    l_tmp[1] = 0
    l_tmp[2] = 0
    l_tmp[3] = 0
    l_tmp[4] = 0
    l_tmp[5] = 0
    l_tmp[6] = 0
    l_tmp[7] = p_product[23]
    l_tmp[8] = p_product[24]
    l_tmp[9] = p_product[25]
    l_tmp[10] = p_product[26]
    l_tmp[11] = p_product[27]
    l_tmp[12] = p_product[28]
    l_tmp[13] = p_product[29]
    l_tmp[14] = p_product[30]
    l_tmp[15] = p_product[31]
    l_tmp[16] = p_product[32]
    l_carry = vli_lshift(l_tmp,l_tmp,1)
    l_carry =l_carry + vli_add(p_result,p_result,l_tmp)
    --s2--
    l_tmp[5] = 0
    l_tmp[6] = 0
    l_tmp[7] = p_product[26]
    l_tmp[8] = p_product[25]
    l_tmp[9] = p_product[27]
    l_tmp[10] = p_product[28]
    l_tmp[11] = p_product[29]
    l_tmp[12] = p_product[30]
    l_tmp[13] = p_product[31]
    l_tmp[14] = p_product[32]
    l_tmp[15] = 0
    l_tmp[16] = 0
    l_carry = l_carry + vli_lshift(l_tmp,l_tmp,1)
    l_carry = vli_add(p_result,p_result,l_tmp)

    --s3
    l_tmp[1] = p_product[17]
    l_tmp[2] = p_product[18]
    l_tmp[3] = p_product[19]
    l_tmp[4] = p_product[20]
    l_tmp[5] = p_product[21]
    l_tmp[6] = p_product[22]
    l_tmp[7] = 0
    l_tmp[8] = 0
    l_tmp[9] = 0
    l_tmp[10] = 0
    l_tmp[11] = 0
    l_tmp[12] = 0
    l_tmp[13] = p_product[29]
    l_tmp[14] = p_product[30]
    l_tmp[15] = p_product[31]
    l_tmp[16] = p_product[32]
    l_carry = l_carry + vli_add(p_result,p_result,l_tmp)

    --s4
    l_tmp[1] = p_product[19]
    l_tmp[2] = p_product[20]
    l_tmp[3] = p_product[21]
    l_tmp[4] = p_product[22]
    l_tmp[5] = p_product[28]
    l_tmp[6] = p_product[27]
    l_tmp[7] = p_product[24]
    l_tmp[8] = p_product[23]
    l_tmp[9] = p_product[29]
    l_tmp[10] = p_product[30]
    l_tmp[11] = p_product[31]
    l_tmp[12] = p_product[32]
    l_tmp[13] = p_product[27]
    l_tmp[14] = p_product[28]
    l_tmp[15] = p_product[17]
    l_tmp[16] = p_product[18]
    l_carry = l_carry + vli_add(p_result,p_result,l_tmp)

    --d1
    l_tmp[1] = p_product[23]
    l_tmp[2] = p_product[24]
    l_tmp[3] = p_product[25]
    l_tmp[4] = p_product[26]
    l_tmp[5] = p_product[27]
    l_tmp[6] = p_product[28]
    l_tmp[7] = 0
    l_tmp[8] = 0
    l_tmp[9] = 0
    l_tmp[10] = 0
    l_tmp[11] = 0
    l_tmp[12] = 0
    l_tmp[13] = p_product[17]
    l_tmp[14] = p_product[18]
    l_tmp[15] = p_product[21]
    l_tmp[16] = p_product[22]
    l_carry = l_carry - vli_sub(p_result,p_result,l_tmp)
    --d2
    l_tmp[1] = p_product[25]
    l_tmp[2] = p_product[26]
    l_tmp[3] = p_product[27]
    l_tmp[4] = p_product[28]
    l_tmp[5] = p_product[29]
    l_tmp[6] = p_product[30]
    l_tmp[7] = p_product[31]
    l_tmp[8] = p_product[32]
    l_tmp[9] = 0
    l_tmp[10] = 0
    l_tmp[11] = 0
    l_tmp[12] = 0
    l_tmp[13] = p_product[19]
    l_tmp[14] = p_product[20]
    l_tmp[15] = p_product[23]
    l_tmp[16] = p_product[24]
    l_carry = l_carry - vli_sub(p_result,p_result,l_tmp)
    --d3
    l_tmp[1] = p_product[27]
    l_tmp[2] = p_product[28]
    l_tmp[3] = p_product[29]
    l_tmp[4] = p_product[30]
    l_tmp[5] = p_product[31]
    l_tmp[6] = p_product[32]
    l_tmp[7] = p_product[17]
    l_tmp[8] = p_product[18]
    l_tmp[9] = p_product[19]
    l_tmp[10] = p_product[20]
    l_tmp[11] = p_product[21]
    l_tmp[12] = p_product[22]
    l_tmp[13] = 0
    l_tmp[14] = 0
    l_tmp[15] = p_product[25]
    l_tmp[16] = p_product[26]
    l_carry = l_carry - vli_sub(p_result,p_result,l_tmp)
    --d4
    l_tmp[1] = p_product[29]
    l_tmp[2] = p_product[30]
    l_tmp[3] = p_product[31]
    l_tmp[4] = p_product[32]
    l_tmp[5] = 0
    l_tmp[6] = 0
    l_tmp[7] = p_product[19]
    l_tmp[8] = p_product[20]
    l_tmp[9] = p_product[21]
    l_tmp[10] = p_product[22]
    l_tmp[11] = p_product[23]
    l_tmp[12] = p_product[24]
    l_tmp[13] = 0
    l_tmp[14] = 0
    l_tmp[15] = p_product[27]
    l_tmp[16] = p_product[28]
    l_carry = l_carry - vli_sub(p_result,p_result,l_tmp)
    if l_carry <0 then
        l_carry = l_carry + vli_add(p_result,p_result,Curve_P)
        while l_carry<0 do
            l_carry = l_carry + vli_add(p_result,p_result,Curve_P)
        end
    else
        while true do
            if (l_carry > 0 or vli_cmp(Curve_P,p_result) ~= 1) then
                l_carry = l_carry - vli_sub(p_result,p_result,Curve_P)
            else
                break
            end
        end
    end
end
function vli_modMult_fast(p_result,p_left,p_right)
    local l_product = {}
    vli_mult(l_product,p_left,p_right)
    vli_mmod_fast(p_result,l_product)
end

function vli_modSquare_fast(p_result,p_left)
    local l_product = {}
    vli_square(l_product,p_left)
    vli_mmod_fast(p_result,l_product)
end
function vli_isEven(num)
    return bit.band(num[1],0x01) == 1
end
function vil_modInv(p_result,p_input,p_mod)
    local a = {}
    local b = {}
    local u = {}
    local v = {}
    local l_carry ={}
    local l_cmpResult

    if vli_isZero(p_input) then
        vli_clear(p_result)
        return
    end
    vli_set(a,p_input)
    vli_set(b,p_mod)
    vli_clear(u)
    u[1] = 1
    vli_clear(v)
    l_cmpResult = vli_cmp(a,b)
    while l_cmpResult~=0 do
        l_carry = 0
        if vli_isEven(a) then
            vli_rshift1(a)
            if vli_isEven(u) ~= true then
                l_carry = vli_add(u,u,p_mod)
            end
            vli_rshift1(u)
            if(l_carry~=0)then
                u[16] = bit.bor(0x8000,u[16])
            end
        elseif vli_isEven(b) then
            vli_rshift1(b)
            if vli_isEven(v) ~= true then
                l_carry = vli_add(v,v,p_mod)
            end
            vli_rshift1(v)
            if(l_carry~=0)then
                v[16] = bit.bor(0x8000,v[16])
            end
        elseif l_cmpResult >0 then
            vli_sub(a,a,b)
            vli_rshift1(a)
            if vli_cmp(u,v) <0 then
                vli_add(u,u,p_mod)
            end
            vli_sub(u,u,v)
            if vli_isEven(u) ~= true then
                l_carry = vli_add(u,u,p_mod)
            end
            vli_rshift1(u)
            if l_carry~=0 then
                u[16] = bit.bor(0x8000,u[16])
            end
        else
            vli_sub(b,b,a)
            vli_rshift1(b)
            if vli_cmp(v,u) <0 then
                vli_add(v,v,p_mod)
            end
            vli_sub(v,v,u)
            if vli_isEven(v) ~=true then
                l_carry = vli_add(v,v,p_mod)
            end
            vli_rshift1(v)
            if l_carry ~= 0 then
                v[16] = bit.bor(0x8000,v[16])
            end
        end
        l_cmpResult = vli_cmp(a,b)
    end
    vli_set(p_result,u)
end
function vli_modMult(p_result,p_left,p_right,p_mod)
    local l_product = {}

    local l_modMultiple ={}
    local l_digitShift
    local l_bitShift
    local l_productBits
    local l_modBits = vli_numBits(p_mod)

    vli_mult(l_product,p_left,p_right)
    local l_tmp = {}
    for i = number_ecc_digits+1,number_ecc_digits+4 do
        l_tmp [i-number_ecc_digits] = l_product[i]
    end
    l_productBits = vli_numBits(l_tmp)
    if(l_productBits ~= 0) then
        l_productBits = l_productBits +number_ecc_digits *16
    else
        l_productBits = vli_numBits(l_product)
    end
    if(l_productBits < l_modBits) then
        vli_set(p_result,l_product)
        return
    end
    vli_clear(l_modMultiple)
    for i =number_ecc_digits+1,number_ecc_digits*2 do
        p_vli[i]=0
    end

    l_digitShift = (l_productBits - l_modBits)/16
    l_bitShift = (l_productBits - l_modBits)%16
    if l_bitShift  ~= 0 then
        local tmp  = {}
        vli_lshift(tmp,p_mod,l_bitShift)
        for i = l_digitShift+1, l_digitShift+number_ecc_digits do
            l_modMultiple[i] = tmp[i-l_digitShift+1]
        end
    else
        for i = l_digitShift+1, l_digitShift+number_ecc_digits do
            l_modMultiple[i] = p_mod[i-l_digitShift]
        end
    end
    vli_clear(p_result)
    p_result[1] = 1
    while (l_productBits > number_ecc_digits*16 or vli_cmp(l_modMultiple,p_mod)>=0) do
        local l_tmp = {}
        local l_cmp = vli_cmp(vli_subTable(l_modMultiple,number_ecc_digits+1,2*number_ecc_digits),vli_subTable(l_product,number_ecc_digits+1,2*number_ecc_digits))
        if (l_cmp <0 or( l_cmp == 0 and vli_cmp(l_modMultiple,l_product)<=0)) then
            if (vli_sub(l_product,l_product,l_modMultiple)) then
                vli_sub(l_tmp , vli_subTable(l_product,number_ecc_digits+1,number_ecc_digits*2),p_result)
                for i = number_ecc_digits +1 ,number_ecc_digits*2 do
                    l_product[number_ecc_digits +1] = l_tmp[i-number_ecc_digits]
                end
            end
            vli_sub(l_tmp , vli_subTable(l_product,number_ecc_digits+1,number_ecc_digits*2),vli_subTable(l_modMultiple,number_ecc_digits+1,number_ecc_digits*2))
            for i = number_ecc_digits +1 ,number_ecc_digits*2 do
                l_product[number_ecc_digits +1] = l_tmp[i-number_ecc_digits]
            end
        end
        local l_carry = {}
        l_carry[1] = bit.lshift(bit.band(l_modMultiple[number_ecc_digits +1],0x01),15)
        l_carry[2] = 0
        l_carry[3] = 0
        l_carry[4] = 0
        tmp = vli_subTable(l_modMultiple,number_ecc_digits+1,number_ecc_digits*2)
        vli_rshift1(tmp)
        for i= 1,number_ecc_digits do
            l_modMultiple[i+number_ecc_digits] = tmp[i]
        end
        vli_rshift1(l_modMultiple)
        for i = 1 ,4 do
            l_modMultiple[number_ecc_digits-4+i] = bit.bor(l_modMultiple[number_ecc_digits-4+i],l_carry[i])
        end
        l_productBits = l_productBits -1
    end
    vli_set(p_result,l_product)
end
function eccPoint_double_jacobian(X1,Y1,Z1)
    local t4 ={}
    local t5 ={}

    if vli_isZero(Z1) then
        return
    end

    vli_modSquare_fast(t4, Y1);   -- t4 = y1^2
    vli_modMult_fast(t5, X1, t4); -- t5 = x1*y1^2 = A
    vli_modSquare_fast(t4, t4);   -- t4 = y1^4
    vli_modMult_fast(Y1, Y1, Z1); -- t2 = y1*z1 = z3
    vli_modSquare_fast(Z1, Z1);   -- t3 = z1^2

    vli_modAdd(X1, X1, Z1, Curve_P); -- t1 = x1 + z1^2
    vli_modAdd(Z1, Z1, Z1, Curve_P); -- t3 = 2*z1^2
    vli_modSub(Z1, X1, Z1, Curve_P); -- t3 = x1 - z1^2
    vli_modMult_fast(X1, X1, Z1);    -- t1 = x1^2 - z1^4

    vli_modAdd(Z1,X1,X1,Curve_P) --t3 = 2*(x1^2 -Z1 ^4)
    vli_modAdd(X1,X1,Z1,Curve_P) --t1 = 3*(x1^2 -Z1 ^4)

    if vli_isZero(vli_testBit(X1,0)) ~= true then
        local l_carry = vli_add(X1,X1,Curve_P)
        vli_rshift1(X1)
        X1[16] =  bit.bor(X1[16],bit.lshift(l_carry,15))
    else
        vli_rshift1(X1)
    end
    --t1 = 3/2*(X1^2-Z1^4) = B

    vli_modSquare_fast(Z1,X1) -- t3 = B^2
    vli_modSub(Z1,Z1,t5,Curve_P) -- t3 = B^2 -A
    vli_modSub(Z1,Z1,t5,Curve_P) -- t3 = B^2 -2A = x3
    vli_modSub(t5,t5,Z1,Curve_P) -- t5 = A - x3
    vli_modMult_fast(X1,X1,t5) -- t1 = B*(A - X3)
    vli_modSub(t4,X1,t4,Curve_P) -- t4 = B*(A - x3) -y1^4 = y3

    vli_set(X1,Z1)
    vli_set(Z1,Y1)
    vli_set(Y1,t4)

end
function eccPoint_isZero(p_point)
    return vli_isZero(p_point.x) or vli_isZero(p_point.y)
end
function ecdsa_pub_from_priv(privKey)

    if privKey then

    end
end

function ecdsa_sign(p_privateKey ,p_hash,p_signature)
    local k ={}
    local l_tmp ={}
    local l_s ={}
    local l_tries = 1
    local p = EccPoint.new()
    while true do
        getRandomNumber(k)
        if  l_tries >=max_tries then
            return 0
        end
        if vli_isZero(k) ~= true then
            break
        end
        if (vli_cmp(Curve_N,k) ~= 1) then
            vli_sub(k,k,Curve_N)
        end
        eccPoint_mult(p,Curve_G,k,nil)
        if(vli_cmp(Curve_N,p.x) ~= 1) then
            vli_sub(p.x,p.x,Curve_N)
        end
        if vli_isZero(p.x) ~= true then
            break
        end
    end

    ecc_native2bytes(p_signature,p.x)
    ecc_bytes2native(l_tmp,p_privateKey)
    vli_modMult(l_s,p.x,l_tmp,Curve_N)
    ecc_bytes2native(l_tmp,p_hash)
    vli_modAdd(l_s,l_tmp,l_s,Curve_N)
    vli_modInv(k,k,Curve_N)
    vli_modMult(l_s,l_s,k,Curve_N)
    local tmp = {}
    ecc_native2bytes(tmp,l_s)
    for i = number_ecc_bytes+1, number_ecc_bytes*2 do
        p_signature [i] = tmp[i-number_ecc_bytes]
    end
    return 1
end

--p_publicKey is 33 len byte array  p_privateKey is 32 len byte array
function ecc_make_key(p_publicKey,p_privateKey)

    local l_private = {}
    local l_public = EccPoint.new()
    local l_tries = 0
    
    while true do
        getRandomNumber(l_private)
        if  l_tries >=max_tries then
            return 0
        end
        ecc_bytes2native(l_private,string.bytes("testtesttesttesttesttesttesttest",1,32))
        if vli_isZero(l_private) ~= true then
            if (vli_cmp(Curve_N,l_private) ~= 1) then
                vli_sub(l_private,l_private,Curve_N)
            end
            eccPoint_mult(l_public,Curve_G,l_private,nil)
            if eccPoint_isZero(l_public) then
                break
            end
        end
    end
    local l_tmp = {}
    ecc_native2bytes(p_privateKey,l_private)
    ecc_native2bytes(l_tmp,l_public.x)
    for i = 2,i<number_ecc_bytes +1 do
        p_publicKey[i] = l_tmp[i-1]
    end
    ecc_native2bytes(l_tmp,l_public.y)
    for i = 34,i<number_ecc_bytes *2+1 do
        p_publicKey[i] = l_tmp[i-1]
    end
    p_privateKey[1] = 2+bit.band(l_public.y[1],0x01)
    return 1
end


function string:bytes(all)
    if all then
        return { self:byte(1, -1) }
    else
        return byteIter, { t = self, i = 0 }
    end
end
