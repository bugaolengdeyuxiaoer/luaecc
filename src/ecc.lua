---
--- Generated by EmmyLua(https:--github.com/EmmyLua)
--- Created by yj.
--- DateTime: 2020/4/3 15:57
---
local bit = require("bit")
local number_ecc_digits = 16
local number_ecc_bytes = 32
local max_tries = 16
local EccPoint = {
    x = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    y = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
}
function EccPoint.new()
    return {
        x = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        y = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
    }
end
--local Curve_P = {0xFFFFFFFE,0xFFFFFC2F,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF}
--local Curve_B = {0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
--local Curve_G = {0x59F2815B,0x16F81798,0x029BFCDB,0x2DCE28D9,0x55A06295,0xCE870B07,0x79BE667E,0xF9DCBBAC,
--                 0x9C47D08F,0xFB10D4B8,0xFD17B448,0xA6855419,0x5DA4FBFC,0x0E1108A8,0x483ADA77,0x25A3C465}
--local Curve_N = {0xBFD25E8C,0xD0364141,0xBAAEDCE6,0xAF48A038,0xFFFFFFFF,0xFFFFFFFE,0xFFFFFFFF,0xFFFFFFFF}

local Curve_P = {0xFC2F,0xFFFF,0xFFFE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF}
local Curve_B = {0x0007,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000}
local Curve_G = {x = {0x1798,0x16F8,0x815B,0x59F2,0x28D9,0x2DCE,0xFCDB,0x029B,0x0B07,0xCE87,0x6295,0x55A0,0xBBAC,0xF9DC,0x667E,0x79BE},
                y = {0xD4B8,0xFB10,0xD08F,0x9C47,0x5419,0xA685,0xB448,0xFD17,0x08A8,0x0E11,0xFBFC,0x5DA4,0xC465,0x26A3,0xDA77,0x483A}}
local Curve_N = {0x4141,0xD036,0x5E8C,0xBFD2,0xA03B,0xAF48,0xDCE6,0xBAAE,0xFFFE,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF}
function mod_sqrt(a)
    local p1 = {}
    vli_clear(p1)
    p1 [1] = 1
    local l_result = {}
    vli_clear(l_result)
    l_result [1] = 1
    --Since Curve_P == 3 (mod 4) for all supported curves, we can
    --compute sqrt(a) = a^((Curve_P + 1) / 4) (mod Curve_P). 
    vli_add(p1, Curve_P, p1) -- p1 = Curve_P + 1 
    for i = vli_numBits(p1) - 1 , 2,-1 do

        vli_modSquare_fast(l_result, l_result)
        if(vli_isZero(vli_testBit(p1, i))~= true) then
            vli_modMult_fast(l_result, l_result, a)
        end
    end
    vli_set(a, l_result)
end
function ecc_point_decompress(p_point, p_compressed)
    local l_tmp ={}
    for i = 1, 32 do
        l_tmp[i] = p_compressed[i+1]
    end
    ecc_bytes2native(p_point.x,l_tmp)
    vli_modSquare_fast(p_point.y, p_point.x) -- y = x^2 
    vli_modMult_fast(p_point.y, p_point.y,p_point.x) -- y = x^3 
    vli_modAdd(p_point.y, p_point.y, Curve_B, Curve_P) -- y = x^3 + 7 
    mod_sqrt(p_point.y)
    if(bit.band(p_point.y[1] , 0x01)) ~= bit.band(p_compressed[1] , 0x01) then
        vli_sub(p_point.y, Curve_P, p_point.y)
    end
end
function ecdsa_verify(p_publicKey, p_hash, p_signature)
    local u1 ={}

    local u2 = {}
    local z = {}

    local l_public = EccPoint.new()
    local l_sum = EccPoint.new()
    local rx = {}
    local ry={}
    local tx={}
    local ty={}
    local tz={}

    local l_r={}
    local l_s={}
    ecc_point_decompress(l_public, p_publicKey)
    ecc_bytes2native(l_r, p_signature)
    local l_tmp = {}
    for i = 1 ,32 do
        l_tmp [i] = p_signature[i+32]
    end
    ecc_bytes2native(l_s, l_tmp)

    if(vli_isZero(l_r) or vli_isZero(l_s)) then
        -- r, s must not be 0. 
        return false
    end

    if vli_cmp(Curve_N, l_r) ~= 1 or vli_cmp(Curve_N, l_s) ~= 1 then
        -- r, s must be < n. 
        return false
    end

    -- Calculate u1 and u2. 
    vli_modInv(z, l_s, Curve_N) -- Z = s^-1 
    ecc_bytes2native(u1, p_hash)
    vli_modMult(u1, u1, z, Curve_N) -- u1 = e/s 
    vli_modMult(u2, l_r, z, Curve_N) -- u2 = r/s 

    -- Calculate l_sum = G + Q. 
    vli_set(l_sum.x, l_public.x)
    vli_set(l_sum.y, l_public.y)
    vli_set(tx, Curve_G.x)
    vli_set(ty, Curve_G.y)
    vli_modSub(z, l_sum.x, tx, Curve_P) -- Z = x2 - x1 
    XYcZ_add(tx, ty, l_sum.x, l_sum.y)
    vli_modInv(z, z, Curve_P) -- Z = 1/Z 
    apply_z(l_sum.x, l_sum.y, z)

    -- Use Shamir's trick to calculate u1*G + u2*Q 
    local l_points = {}
    l_points[1]  = nil
    l_points[2]  = Curve_G
    l_points[3]  = l_public
    l_points[4]  = l_sum
    local l_numBits = math.max(vli_numBits(u1), vli_numBits(u2))
    local c1
    if vli_isZero(vli_testBit(u1, l_numBits-1)) then
        c1 = 0
    else
        c1 = 1
    end
    local c2
    if vli_isZero(vli_testBit(u2, l_numBits-1)) then
        c2 = 0
    else
        c2 = 1
    end
    local l_point = l_points[bit.bor(c1 , bit.lshift(c2, 1))+1]
    vli_set(rx, l_point.x)
    vli_set(ry, l_point.y)
    vli_clear(z)
    z[1] = 1

    for i = l_numBits - 1 ,1 ,-1 do
        eccPoint_double_jacobian(rx, ry, z)
        local c1
        if vli_isZero(vli_testBit(u1, i-1)) then
            c1 = 0
        else
            c1 = 1
        end
        local c2
        if vli_isZero(vli_testBit(u2, i-1)) then
            c2 = 0
        else
            c2 = 1
        end
        local l_index = bit.bor((c1) , bit.lshift(c2, 1))+1
        l_point = l_points[l_index]
        if(l_point ~= nil) then
            vli_set(tx, l_point.x)
            vli_set(ty, l_point.y)
            apply_z(tx, ty, z)
            vli_modSub(tz, rx, tx, Curve_P) -- Z = x2 - x1 
            XYcZ_add(tx, ty, rx, ry)
            vli_modMult_fast(z, z, tz)
        end
    end
    vli_modInv(z, z, Curve_P) -- Z = 1/Z 
    apply_z(rx, ry, z)

    -- v = x1 (mod n) 
    if(vli_cmp(Curve_N, rx) ~= 1) then
        vli_sub(rx, rx, Curve_N)
    end

    -- Accept only if v == r. 
    return (vli_cmp(rx, l_r) == 0)
end
function getRandomNumber(p_vli)
    for i = 1,number_ecc_digits do
        p_vli [i] = math.random(1,65536)
    end
end
function XYcZ_initial_double(X1,Y1,X2,Y2,p_initialZ)
    local z = {}
    vli_set(X2,X1)
    vli_set(Y2,Y1)

    vli_clear(z)
    z[1] = 1
    if p_initialZ ~= nil then
        vli_set(z,p_initialZ)
    end
    apply_z(X1,Y1,z)
    eccPoint_double_jacobian(X1,Y1,z)
    apply_z(X2,Y2,z)
end

-- Input P = (X1,Y1,Z) Q = (X2,Y2,Z)
-- Output P' = (X1,Y1,Z3) P + Q = (X3,Y3,Z3)
-- or P => P'  ,Q => P+Q
function XYcZ_add(X1,Y1,X2,Y2)
    local t5 = {}
    vli_modSub(t5,X2,X1,Curve_P)  --t5 = x2-x1
    vli_modSquare_fast(t5,t5)  --t5 = (x2-x1)^2 =A
    vli_modMult_fast(X1,X1,t5)  --t1 = x1*A =B
    vli_modMult_fast(X2,X2,t5)  --t3 = x2*A = C
    vli_modSub(Y2,Y2,Y1,Curve_P)  --t4 = y2-y1
    vli_modSquare_fast(t5,Y2)  --t5 = (y2-y1)^2 =D

    vli_modSub(t5,t5,X1,Curve_P)  --t5 = D-B
    vli_modSub(t5,t5,X2,Curve_P)  --t5 = D-B -C = x3
    vli_modSub(X2,X2,X1,Curve_P)  --t3 = C-B
    vli_modMult_fast(Y1,Y1,X2)  --t2 = y1*(C-B)
    vli_modSub(X2,X1,t5,Curve_P)  --t3 = B-x3
    vli_modMult_fast(Y2,Y2,X2)  --t4 = (y2-y1)*(B-x3)
    vli_modSub(Y2,Y2,Y1,Curve_P)  --t4 = y3

    vli_set(X2,t5)
end
function XYcZ_addC(X1,Y1,X2,Y2)
    local t5 = {}
    local t6 = {}
    local t7 = {}
    vli_modSub(t5,X2,X1,Curve_P)  --t5 = x2-x1
    vli_modSquare_fast(t5,t5)  --t5 = x2-x1
    vli_modMult_fast(X1,X1,t5) --t1 = x1 *A = B
    vli_modMult_fast(X2,X2,t5) --t3 = x2*A =C
    vli_modAdd(t5,Y2,Y1,Curve_P) --t4 =y2 + y1
    vli_modSub(Y2,Y2,Y1,Curve_P) --t4 = y2-y1

    vli_modSub(t6,X2,X1,Curve_P)  --t6 =C-B
    vli_modMult_fast(Y1,Y1,t6)  --t5 = y1*(C-B)
    vli_modAdd(t6,X1,X2,Curve_P)  --t6 = B+C
    vli_modSquare_fast(X2,Y2)  --t3 = (y2-y1)^2
    vli_modSub(X2,X2,t6,Curve_P)  --t3 = x3

    vli_modSub(t7,X1,X2,Curve_P)  --t7 = B-x3
    vli_modMult_fast(Y2,Y2,t7)  --t4 = (y2-y1)*(B- X3)
    vli_modSub(Y2,Y2,Y1,Curve_P)  --t4 =y3

    vli_modSquare_fast(t7,t5)  --t7 =(y2 +y1)^2 = F
    vli_modSub(t7,t7,t6,Curve_P)  --t7 = x3'
    vli_modSub(t6,t7,X1,Curve_P)  --t6 = x3'-B
    vli_modMult_fast(t6,t6,t5)  --t6 = (y2+y1)*(x3' - B)
    vli_modSub(Y1,t6,Y1,Curve_P)  --t2 = y3'

    vli_set(X1,t7)
end

function apply_z(X1,Y1,Z)
    local t1 ={}
    vli_modSquare_fast(t1,Z) --Z^2
    vli_modMult_fast(X1,X1,t1) --x1*Z^2
    vli_modMult_fast(t1,t1,Z) --Z^3
    vli_modMult_fast(Y1,Y1,t1) --y1*Z^3

end
---EccPoint p_result EccPoint p_point uint64 p_scalar uint64 p_initialZ
function eccPoint_mult(p_result,p_point,p_scalar,p_initialZ)
    --Ro and R1
    local Rx = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}}
    local Ry = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}}
    local z = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}

    local nb
    vli_set(Rx[2],p_point.x)
    vli_set(Ry[2],p_point.y)
    XYcZ_initial_double(Rx[2],Ry[2],Rx[1],Ry[1],p_initialZ)
    for i = vli_numBits(p_scalar)-1,2,-1 do
        if vli_isZero(vli_testBit(p_scalar,i-1))  then
            nb = 1
        else
            nb = 0
        end
        XYcZ_addC(Rx[1-nb+1], Ry[1-nb+1], Rx[nb+1], Ry[nb+1])
        XYcZ_add(Rx[nb+1], Ry[nb+1], Rx[1-nb+1], Ry[1-nb+1])
    end
    if vli_isZero(vli_testBit(p_scalar,0))  then
        nb = 1
    else
        nb = 0
    end
    XYcZ_addC(Rx[1-nb+1],Ry[1-nb+1],Rx[nb+1],Ry[nb+1])

    --find final 1/Z value
    vli_modSub(z,Rx[2],Rx[1],Curve_P)
    vli_modMult_fast(z,z,Ry[1-nb+1])
    vli_modMult_fast(z,z,p_point.x)
    vli_modInv(z,z,Curve_P)
    vli_modMult_fast(z,z,p_point.y)
    vli_modMult_fast(z,z,Rx[1-nb+1])

    XYcZ_add(Rx[nb+1],Ry[nb+1],Rx[1-nb+1],Ry[1-nb+1])
    apply_z(Rx[1],Ry[1],z)

    vli_set(p_result.x,Rx[1])
    vli_set(p_result.y,Ry[1])
end
--p_bytes is uint8 array
function ecc_bytes2native(p_native,p_bytes)
    for i = 1,number_ecc_digits do
        local p_digit = 2*(number_ecc_digits-i)
        p_native[i] = bit.bor(bit.lshift(p_bytes[p_digit+1],8),p_bytes[p_digit+2])
    end
end
--p_bytes is uint8 array
function ecc_native2bytes(p_bytes,p_native)
    for i = 1,number_ecc_digits do
        local p_digit = number_ecc_digits-i+1
        p_bytes[i*2-1] = bit.band(bit.rshift(p_native[p_digit],8),0xff)
        p_bytes[i*2] = bit.band(p_native[p_digit],0xff)
    end
end
function ecc_native2hex(p_native)
    local  hexStr = ""
    for i = 1,number_ecc_digits do
        local p_digit = number_ecc_digits-i+1
        hexStr = hexStr ..string.format("%02X",bit.band(bit.rshift(p_native[p_digit],8),0xff))
        hexStr = hexStr ..string.format("%02X",bit.band(p_native[p_digit],0xff))
    end
    return hexStr
end
function ecc_hex2native(p_native)
    local  bytes = {}
    for i = 1 ,number_ecc_digits*2 do
        bytes[i] = tonumber(string.sub(p_native,i,i),16)*16 + tonumber(string.sub(p_native,i+1,i+1),16)
    end
    return bytes
end
function vli_numDigits(p_vli)
    local j =number_ecc_digits
    for i = number_ecc_digits ,1,-1  do
        if p_vli[i]~=0 then
            j = i
            break
        end
        j = j-1
    end
    return j
end

function vli_numBits(p_vli)
    local i = 0
    local l_digit = 0
    local l_numDigits = vli_numDigits(p_vli)
    if(l_numDigits == 0) then
        return 0
    end

    i = (l_numDigits-1) *16
    l_digit = p_vli[l_numDigits]
    while l_digit>0 do
        i = i+1
        l_digit = bit.rshift(l_digit,1)
    end
    return i
end

function vli_isZero(p_vli)
    for i =1,#p_vli do
        if p_vli[i]~=0 then
            return false
        end
    end
    return true
end

function vli_clear(p_vli)
    for i =1,number_ecc_digits do
        p_vli[i]=0
    end
    return 1
end
function vli_set(p_dest,p_src)
    for i =1,number_ecc_digits do
        p_dest[i] = p_src[i]
    end
end

--returns nonzeor if bit p_bit of p_vli is set
function vli_testBit(p_vli,p_bit)
    local r = {}
    local a = math.floor(p_bit/16)
    b = a
    while b>4 do
        b = b-4
    end
    r [1]  = 0
    r [2]  = 0
    r [3]  = 0
    r [4]  = 0
    r[b+1] = bit.band(p_vli[a+1],bit.lshift(1,p_bit%16))
    return r
end

function vli_cmp(p_left,p_right)
    for i =number_ecc_digits,1,-1 do
        if p_left[i]>p_right[i] then
            return 1
        elseif  p_left[i]<p_right[i] then
            return -1
        end
    end
    return 0
end
function vli_lshift(p_result,p_in,p_shift)
    local l_carry =0
    for i = 1,number_ecc_digits do
        local l_temp = p_in[i]
        p_result[i] = bit.band(bit.bor(bit.lshift(l_temp,p_shift),l_carry),0xffff)
        --l_carry = bit.rshift(l_temp,16-p_shift)
        l_carry = math.floor(l_temp/bit.lshift(1,16-p_shift))
    end
    return l_carry
end
--rshift 1 bit
function vli_rshift1(p_in)
    local l_carry = 0
    local p_temp = 0
    local p_vil = number_ecc_digits
    for i = p_vil,1,-1 do
        p_temp = p_in[i]
        p_in[i] = bit.bor(bit.rshift(p_in[i],1),bit.lshift(l_carry,15))
        l_carry = bit.band(p_temp,0x1)
    end
end

--computes p_result = p_left+p_right ,return carry
function vli_add(p_result,p_left,p_right)
    local l_carry = 0
    local p_temp = 0
    for i = 1,number_ecc_digits do
        local l_sum = p_left[i]+p_right[i]+l_carry
        if l_sum ~= p_left[i] then
            if (l_sum >65535) then
                l_carry =  math.floor(l_sum/65536)
            else
                l_carry = 0
            end
        end
        if l_sum >65535 then
            p_result[i] = l_sum - 65536
        else
            p_result[i] = l_sum
        end
    end
    return l_carry
end
--computes p_result = p_left-p_right ,return carry
function vli_sub(p_result,p_left,p_right)
    local l_borrow = 0
    for i = 1,number_ecc_digits do
        local l_diff = p_left[i]-p_right[i]-l_borrow
        if(l_diff<0) then
            p_result[i] = l_diff +65536
            l_borrow =1
        else
            p_result[i] = l_diff
            l_borrow = 0
        end
    end
    return l_borrow
end

function vli_mult(p_result,p_left,p_right)
    local r01= 0
    local k = 1
    repeat
        local l_min
        if (k<=number_ecc_digits) then
            l_min = 1
        else
            l_min= (k+1)-number_ecc_digits
        end
        local i = l_min
        repeat
            local l_product = p_left[i] * p_right[k-i+1]
            r01 = r01 + l_product
            i = i+1
        until i>k or i> number_ecc_digits
        p_result[k] = bit.band(r01,0xffff)
        r01 = math.floor(r01 /65536)
        k = k+1
    until k>number_ecc_digits*2-1
    p_result[number_ecc_digits*2] = bit.band(r01,0xffff)
end
-- computes p_result^2
function vli_square(p_result,p_left)
    local r01 = 0
    local k = 1
    local l_min
    repeat
        if (k<=number_ecc_digits) then
            l_min = 1
        else
            l_min = (k+1-number_ecc_digits)
        end
        for i = l_min,k  do
            if (i>k-i+1) then
                break
            end
            local l_product = p_left[i] * p_left[k-i+1]
            if i <= k - i then
                l_product = l_product*2
            end
            r01  =r01 + l_product
        end
        p_result[k] = bit.band(0xffff,r01)
        r01 = math.floor(r01 /65536)
        k = k+1
    until k>number_ecc_digits*2-1

    p_result[number_ecc_digits*2] = bit.band(0xffff,r01)
end

function vli_modAdd(p_result,p_left,p_right,p_mod)
    local l_carry = vli_add(p_result,p_left,p_right)
    if l_carry >=1 or vli_cmp(p_result,p_mod)>=0 then
        vli_sub(p_result,p_result,p_mod)
    end

end
function vli_modSub(p_result,p_left,p_right,p_mod)
    local l_borrow = vli_sub(p_result,p_left,p_right)
    if l_borrow ~= 0 then
        vli_add(p_result,p_result,p_mod)
    end
end
function vli_subTable(p_left,p,q)
    local o = 1
    local p_result = {}
    for k = p,q do
        p_result [o] = p_left[k]
        o = o + 1
    end
    return p_result
end
function vli_mmod_fast(p_result,p_product)
    local l_carry = 0
    local  p_temp_array = {0x03D1,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000}


    local p_product_right = {}
    for i =1,16 do
        p_product_right[i] = p_product[i+number_ecc_digits]
    end
    local l_tmp = {}
    vli_mult(l_tmp,p_temp_array,p_product_right)
    if vli_cmp(p_product,Curve_P)>=0 then
        vli_sub(p_product,p_product,Curve_P)
    end
    l_carry = vli_add(p_product,l_tmp,p_product)
    l_tmp[17] = l_tmp[17] + l_carry


    local aa = {}
    for i = 1,16 do
        aa[i] = l_tmp[i+16]
    end
    for  i = 1 ,32 do
        l_tmp[i] = 0
    end
    vli_mult(l_tmp,p_temp_array,aa)
    l_carry = vli_add(p_product,l_tmp,p_product)
    while l_carry >0 do
    l_carry  = l_carry + vli_add(p_product,p_product,p_temp_array)
    l_carry =l_carry -1
    end
    if vli_cmp(p_product,Curve_P)>=0 then
    vli_sub(p_product,p_product,Curve_P)
    end
    for  i = 1,16 do
        p_result[i] = p_product[i]
    end
end
function vli_modMult_fast(p_result,p_left,p_right)
    local l_product = {}
    ss,remain = vli_mult(l_product,p_left,p_right)
    vli_mmod_fast(p_result,l_product)
end

function vli_modSquare_fast(p_result,p_left)
    local l_product = {}
    vli_square(l_product,p_left)
    vli_mmod_fast(p_result,l_product)
end
function vli_isEven(num)
    return num[1]%2 == 0
end
function vli_modInv(p_result,p_input,p_mod)
    local a = {}
    local b = {}
    local u = {}
    local v = {}
    local l_carry ={}
    local l_cmpResult

    if vli_isZero(p_input) then
        vli_clear(p_result)
        return
    end
    for i = 1 ,32 do
        a[i] = p_input[i]
    end
    vli_set(b,p_mod)
    vli_clear(u)
    u[1] = 1
    vli_clear(v)
    l_cmpResult = vli_cmp(a,b)
    local i  = 1
    while l_cmpResult~=0 do
        i = i+1
        l_carry = 0
        if vli_isEven(a) then
            vli_rshift1(a)
            if vli_isEven(u) ~= true then
                l_carry = vli_add(u,u,p_mod)
            end
            vli_rshift1(u)
            if(l_carry~=0)then
                u[16] = bit.bor(0x8000,u[16])
            end
        elseif vli_isEven(b) then
            vli_rshift1(b)
            if vli_isEven(v) ~= true then
                l_carry = vli_add(v,v,p_mod)
            end
            vli_rshift1(v)
            if(l_carry~=0)then
                v[16] = bit.bor(0x8000,v[16])
            end
        elseif l_cmpResult >0 then
            vli_sub(a,a,b)
            vli_rshift1(a)
            if vli_cmp(u,v) <0 then
                vli_add(u,u,p_mod)
            end
            vli_sub(u,u,v)
            if vli_isEven(u) ~= true then
                l_carry = vli_add(u,u,p_mod)
            end
            vli_rshift1(u)
            if l_carry~=0 then
                u[16] = bit.bor(0x8000,u[16])
            end
        else
            vli_sub(b,b,a)
            vli_rshift1(b)
            if vli_cmp(v,u) <0 then
                vli_add(v,v,p_mod)
            end
            vli_sub(v,v,u)
            if vli_isEven(v) ~=true then
                l_carry = vli_add(v,v,p_mod)
            end
            vli_rshift1(v)
            if l_carry ~= 0 then
                v[16] = bit.bor(0x8000,v[16])
            end
        end
        l_cmpResult = vli_cmp(a,b)
    end
    vli_set(p_result,u)
end

function vli_modMult(p_result,p_left,p_right,p_mod)
    local p_product = {}
    vli_mult(p_product,p_left,p_right)
    vli_mmod(p_result,p_product,p_mod)
end
function vli_clear32(vli)
    for i = 1 ,32 do
        vli[i]= 0
    end
end
function vli_mmod(p_result,p_product,p_mod)

    --size is 32
    local mod_multiple={}
    --size is 32
    local tmp={}
    local v = {tmp, p_product}
    local index
    -- Shift mod so its highest set bit is at the maximum position.
    local shift = 512 - vli_numBits(p_mod)
    local word_shift = math.floor(shift / 16)
    local bit_shift = shift % 16
    local carry = 0
    vli_clear32(mod_multiple)
    vli_clear32(tmp)
    if (bit_shift > 0) then
        for index = 1, number_ecc_digits do
            mod_multiple[word_shift + index] = bit.bor(bit.lshift(p_mod[index], bit_shift) , carry)
            carry = bit.rshift(p_mod[index] ,(number_ecc_digits - bit_shift))
        end
    else
        for i = 1 ,16 do
            mod_multiple[i+number_ecc_digits] = p_mod[i]
        end
    end
    index = 1
    repeat
        local borrow = 0
        for i =1, number_ecc_digits * 2 do
            local diff = v[index+1][i] - mod_multiple[i] - borrow
            if(diff<0) then
                v[1 - index+1][i] = diff +65536
                borrow =1
            else
                v[1 - index+1][i]  = diff
                borrow = 0
            end
        end
        index = 1-(bit.bxor(index , borrow)) -- Swap the index if there was no borrow
        vli_rshift1(mod_multiple)
        mod_multiple[16] = bit.bor(mod_multiple[16],bit.lshift(mod_multiple[17], (16 - 1))%65536)
        local temp = {}
        for i = 1 ,number_ecc_digits do
            temp[i] = mod_multiple[i+number_ecc_digits]
        end
        vli_rshift1(temp)
        for i = 1 ,number_ecc_digits do
            mod_multiple[i+number_ecc_digits] = temp[i]
        end
        shift = shift -1
    until shift <0

    vli_set(p_result, v[index+1])
end
function eccPoint_double_jacobian(X1,Y1,Z1)
    local t4 ={}
    local t5 ={}

    if vli_isZero(Z1) then
        return
    end

    vli_modSquare_fast(t5, Y1)   --t5 = y1^2 
    vli_modMult_fast(t4, X1, t5) --t4 = x1*y1^2 = A 
    vli_modSquare_fast(X1, X1)   --t1 = x1^2 
    vli_modSquare_fast(t5, t5)   --t5 = y1^4 
    vli_modMult_fast(Z1, Y1, Z1) --t3 = y1*z1 = z3 

    vli_modAdd(Y1, X1, X1, Curve_P) --t2 = 2*x1^2 
    vli_modAdd(Y1, Y1, X1, Curve_P) --t2 = 3*x1^2 

    if vli_isZero(vli_testBit(Y1,0)) ~= true then
        local l_carry = vli_add(Y1,Y1,Curve_P)
        vli_rshift1(Y1)
        Y1[16] =  bit.bor(Y1[16],bit.lshift(l_carry,15))
    else
        vli_rshift1(Y1)
    end
    --t1 = 3/2*(X1^2-Z1^4) = B

    vli_modSquare_fast(X1, Y1)                     --t1 = B^2 
    vli_modSub(X1, X1, t4, Curve_P) --t1 = B^2 - A 
    vli_modSub(X1, X1, t4, Curve_P) --t1 = B^2 - 2A = x3 

    vli_modSub(t4, t4, X1, Curve_P) --t4 = A - x3 
    vli_modMult_fast(Y1, Y1, t4)                   --t2 = B * (A - x3) 
    vli_modSub(Y1, Y1, t5, Curve_P) --t2 = B * (A - x3) - y1^4 = y3 
end
function eccPoint_isZero(p_point)
    return vli_isZero(p_point.x) or vli_isZero(p_point.y)
end
function ecdsa_pub_from_priv(privKey)

    if privKey then

    end
end

function ecdsa_sign(p_privateKey ,p_hash,p_signature)
    local k ={}
    local s ={}
    local tmp ={}
    local l_tries = 1
    local signature = {}
    local signature1 = {}
    local p = EccPoint.new()
    while true do
        getRandomNumber(k)
        if  l_tries >=max_tries then
            return 0
        end
        if vli_isZero(k) ~= true then
            break
        end
        if (vli_cmp(Curve_N,k) == 1) and vli_isZero(k) ~= true  then
            break
        end
        l_tries =  l_tries +1
    end

    eccPoint_mult(p, Curve_G, k, nil )

    if vli_isZero(p.x)  then
        return 0
    end

    for i = 1 ,number_ecc_digits do
        tmp [i] = 0x3131
    end

    vli_modMult(k, k, tmp, Curve_N) -- k' = rand * k 
    vli_modInv(k, k, Curve_N)       -- k = 1 / k' 
    vli_modMult(k, k, tmp, Curve_N) -- k = 1 / k 

    ecc_native2bytes(signature, p.x) -- store r 
    ecc_bytes2native(tmp, p_privateKey) -- tmp = d 

    vli_set(s, p.x)
    vli_modMult(s, tmp, s, Curve_N) -- s = r*d 
    ecc_bytes2native(tmp,p_hash)
    vli_modAdd(s, tmp, s, Curve_N) -- s = e + r*d 
    vli_modMult(s, s, k, Curve_N)  -- s = (e + r*d) / k 
    ecc_native2bytes(signature1, s)
    for i = 1 ,32 do
        p_signature[i] = signature[i]
    end
    for i = 1 ,32 do
        p_signature[i+32] = signature1[i]
    end
    return 1
end
function regulark(k2,k1,k)
    local l_carry = 0
    if vli_add(k1,k,Curve_N) >0 or vli_isZero(vli_testBit(k1, 256)) then
        l_carry = 1
    end
    vli_add(k2, k1, Curve_N)
    return l_carry
end
function bytes2hex(bytes)

    local str = ""
    for i = 1,#bytes do
        str = str .. string.format("%x",bytes[i]/16)
        str = str .. string.format("%x",bytes[i]%16)
    end
    return str
end
function hex2bytes(hex)
    if #hex %2 == 1 then
        return nil
    end
    local bytes = ""
    for i = 1,math.floor(#hex/2) do
        bytes[i] = string.format("%d",string.sub(hex,2*i-1,2*i-1))*16 + string.format("%d",string.sub(hex,i*2,i*2))
    end
    return bytes
end
function str2bytes(str)
    local bytes = {}
    for i = 1,#str do
        bytes[i] = string.byte(str,i,i)
    end
    return bytes
end
--p_publicKey is 65 len byte array  p_privateKey is 32 len byte array
function ecc_make_key(p_publicKey,p_privateKey)

    local l_private = {}
    local l_public = EccPoint.new()
    local l_tries = 0

    while true do
        getRandomNumber(l_private)
        if  l_tries >=max_tries then
            return 0
        end
        if vli_isZero(l_private) ~= true then
            if (vli_cmp(Curve_N,l_private) ~= 1) then
                vli_sub(l_private,l_private,Curve_N)
            end
            eccPoint_mult(l_public,Curve_G,l_private,nil)
            if eccPoint_isZero(l_public)~= true then
                break
            end
        end
    end
    ecc_native2bytes(p_privateKey,l_private)
    local pubbytes1 = {}
    p_publicKey[1] = 2+bit.band(l_public.y[1],1)
    ecc_native2bytes(pubbytes1,l_public.x)
    for i = 1 ,32 do
        p_publicKey[i+1] = pubbytes1[i]
    end
end